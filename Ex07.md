## 計算機科学演習　第10回

### 目的:
型と型変換について理解する。

### 本日の内容:
1. 前回の復習
2. 型と型変換

### 前回までの復習（重要項目）
#### 文字（コンピュータ）での文字の扱われ方を理解する
- 文字は通し番号（文字コード）で扱われている
- 半角文字は１バイト、全角文字は２バイト
- 代表的な文字集合  
    ・ASCII … 半角英数字・半角記号 (a,A,0,!,@,# など)   
    ・JIS X 0201 … 半角英数字・半角カナ   
    ・JIS X 0208 … ひらがな・カタカナ・漢字・全角記号 
- エンコーディング  
    複数の文字集合を扱うための枠組み。代表的なエンコーディングには、ISO-2022-JP（区切り用のコードを入れて文字集合を切り替える）と Shift_JIS と EUC-JPがある。

### 型と型変換を理解する

#### データ型とは
- メモリ上に確保する領域のビット長や、確保した領域の扱い方などを決定するもの
- データ型は扱いたいデータの種類（例えば、整数、浮動小数点など）や値の範囲によって決定する。  
  注意: コンピュータ言語の中にはデータ型を自動的に判断して動的に型を変化させるものもある。  

データ型一覧　C言語で使用するデータ型（代表的なもの）
|種類  |データ型  |ビット長 (byte)  |扱える値の範囲  |
|---|---|---|---|
|型なし  |void  |
|文字型  |(signed) char  |8 (1)  |-128～127  |
|文字型  |unsigned char  |8 (1)  |0～255  |
|整数型  |short  |16 (2)  |-32768～32767  |
|整数型  |int  |32 (4)  |-214783648～214783647  |
|浮動小数点型  |float  |32 (4)  |&plusmn;2<sup>-128</sup>～2<sup>127</sup>  |
|浮動小数点型  |double  |64 (8)  |&plusmn;2<sup>-1024</sup>～2<sup>1024</sup>  |
|ポインタ型  |char*, int*…   |32 (4)  |  |

#### 符号有り(signed)と符号なし(unsigned)の違い
- char型 8bit (1 byte)で扱える範囲は 00000000～11111111  
    10進数に直すと0～255までの値を使える。C言語では、頭の(一番左)のビットは符号用の印として扱う（頭の1ビットが0なら正、1なら負）
- char型が数字の値として扱えるのは残りの7ビットだけである  
    7ビット(0000000～1111111)だと、10進数で0～127まで。符号があるから、char型が扱える数値の範囲は-128～127ということになる
- unsignedというオプションをつけると最初の１ビットを符号とするのをやめる  
  したがって、unsigned char型の数値の範囲は0～255となる。通常、signedは省略されておりintやshortで宣言すると符号付で扱われる。(注：浮動小数点型は符号有りのみ)

#### 演習1
signed と unsignedの挙動の違いを確認してみよう
```cpp
#include <stdio.h>

int main()
{
    char s = 100;
    unsigned char u = 100;

    char a = s + u;
    printf("aの場合 %d + %d = %d¥n",s,u,a);

    unsigned char b = s + u;
    printf("aの場合 %d + %d = %d¥n",s,u,b);

    return 0;
}
```

2進数表示をしてそれぞれの挙動を確認してみよう。
```cpp
#include <stdio.h>
  
void cv2bin(unsigned char n)
{
    int DIGITS = 8;

    for( int i = DIGITS-1; i >= 0; i--)
    {
        printf("%d", (n >> i) & 1);
    }
    printf("\n");
}

int main()
{
    char s = 100;
    unsigned char u = 100;

    for(int i = 100; i <= 200; i++)
    {
        printf("signed: %d   unsigned: %d ,  ",s,u);
        cv2bin(u);
        s = i;
        u = i;
    }
    return 0;
}
```
＜解説＞
-56のビットパターンは「11001000」
表示結果より
ビットパターンで「10000000」は-128
であった。また、
ビットパターンで「01001000」は72
である。
これらより -128 + 72 = -56

### 型変換
型変換によって、異なる変数の型を同一演算上で用いることが許される

#### 暗黙の型変換
コンパイラが自動的に無難な型変換を行う
1. 代入時の変換  
左辺の型と右辺の型が異なっている場合は、`左辺の型に変換する`
2. 式の中で行われる変換  
式中で異なる型の定数や変数が現れたときは、`精度の高い型に統一する`（char < int < float < double）

#### 演習2
代入時の変換を確認しよう
```cpp
#include <stdio.h>

int main()
{
    int a;

    double x = 3.1415;

    // int型の変数にdouble型（浮動小数点）を代入する
    a = x;

    // 変数aの数値を表示する
    // 結果: 左辺の型と右辺の型が異なっている場合は、左辺の型に変換する
    printf("aの値は %d です。¥n", a);

    return 0;
}
```

#### 演習3
式の中で行われる変換を確認しよう
```cpp
#include <stdio.h>

int main()
{
    char a = 100;
    int b = 100;
    double c = 23.6;

    double result;
    // double型の変数に型が混合された右辺の計算結果を代入する
    result = a * b + c;

    // 変数aの数値を表示する
    // 結果: 式中で異なる型の定数や変数が現れたときは、精度の高い型に統一する（double型）
    printf("resultの値は %10.4f です。¥n", result);

    return 0;
}
```

#### 明示的型変換（キャスト）
`強制的に別の型に変換したい`ときに用いる  
キャストは`変換したい型を()で囲み変数または計算式の前に置くだけ`

#### 演習4
```cpp
#include <stdio.h>

int main()
{
    int a = 3;
    int b = 2;

    double d1, d2;
    // 右辺はint型のままで計算する
    d1 = a/b;
    // 右辺をdouble型に型変換して計算する
    d2 = (double)a/b;
    // 明示的型変換により結果が異なることを確認する
    printf("d1の値は %10.4f です。¥n", d1);
    printf("d2の値は %10.4f です。¥n", d2);

    return 0;
}
```